"""
Automated Vulnerability Scanner - SANGKURIANG
Real-time vulnerability scanning with automated threat detection
"""

import asyncio
import aiohttp
import json
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Set
from dataclasses import dataclass
from enum import Enum
import hashlib
import re
import subprocess
import tempfile
import os
from urllib.parse import urlparse


class VulnerabilitySeverity(Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class VulnerabilityType(Enum):
    CRYPTOGRAPHIC = "CRYPTOGRAPHIC"
    WEB_SECURITY = "WEB_SECURITY"
    NETWORK = "NETWORK"
    CODE_INJECTION = "CODE_INJECTION"
    AUTHENTICATION = "AUTHENTICATION"
    AUTHORIZATION = "AUTHORIZATION"
    DATA_EXPOSURE = "DATA_EXPOSURE"
    CONFIGURATION = "CONFIGURATION"


@dataclass
class Vulnerability:
    id: str
    type: VulnerabilityType
    severity: VulnerabilitySeverity
    title: str
    description: str
    affected_component: str
    line_number: Optional[int]
    file_path: Optional[str]
    remediation: str
    cvss_score: float
    cwe_id: Optional[str]
    owasp_category: Optional[str]
    discovered_at: datetime
    verified: bool = False


@dataclass
class ScanResult:
    scan_id: str
    target: str
    scan_type: str
    started_at: datetime
    completed_at: Optional[datetime]
    vulnerabilities: List[Vulnerability]
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    medium_count: int
    low_count: int
    info_count: int
    risk_score: float
    compliance_status: str
    scan_duration: float


class AutomatedVulnerabilityScanner:
    """Automated vulnerability scanner with real-time monitoring"""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.vulnerability_database = self._load_vulnerability_database()
        self.scan_history = []
        self.active_scans = {}
        self.monitoring_tasks = {}
        self.monitoring_enabled = False
        self.alert_thresholds = {
            'critical': 1,
            'high': 3,
            'medium': 10
        }
        
        # Properties untuk kompatibilitas dengan test
        self.vulnerability_db = self.vulnerability_database
        self.cve_database = self.vulnerability_database.get('cve_database', {})
        
        # Initialize scanning modules
        self.crypto_scanner = CryptographicVulnerabilityScanner()
        self.web_scanner = WebSecurityScanner()
        self.network_scanner = NetworkSecurityScanner()
        self.code_scanner = CodeSecurityScanner()
        
    def _load_vulnerability_database(self) -> Dict:
        """Load vulnerability database with latest CVE and CWE data"""
        return {
            'cve_database': self._get_cve_database(),
            'cwe_patterns': self._get_cwe_patterns(),
            'owasp_top_10': self._get_owasp_top_10(),
            'crypto_vulnerabilities': self._get_crypto_vulnerabilities(),
            'compliance_standards': self._get_compliance_standards()
        }
    
    def _get_cve_database(self) -> Dict:
        """CVE database for known vulnerabilities"""
        return {
            'CVE-2021-44228': {  # Log4j
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'Log4Shell - Remote code execution in Log4j',
                'affected_versions': ['2.0-beta9', '2.14.1'],
                'cvss_score': 10.0
            },
            'CVE-2020-1472': {  # Zerologon
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'Zerologon elevation of privilege vulnerability',
                'cvss_score': 10.0
            },
            'CVE-2017-0144': {  # WannaCry
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'EternalBlue SMB vulnerability',
                'cvss_score': 8.1
            }
        }
    
    def _get_cwe_patterns(self) -> Dict:
        """CWE (Common Weakness Enumeration) patterns"""
        return {
            'CWE-79': {  # XSS
                'pattern': r'<script.*?>.*?<\/script>|<.*?on\w+\s*=.*?>',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Cross-site scripting vulnerability'
            },
            'CWE-89': {  # SQL Injection
                'pattern': r'(SELECT|INSERT|UPDATE|DELETE).*?\+.*?\+|execute\s*\(.*?\+.*?\)',
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'SQL injection vulnerability'
            },
            'CWE-327': {  # Broken Crypto
                'pattern': r'DES|RC4|MD5|SHA1.*?(encrypt|hash)',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Use of broken cryptographic algorithm'
            },
            'CWE-798': {  # Hardcoded Credentials
                'pattern': r'password\s*=\s*["\'][^"\']+["\']|api_key\s*=\s*["\'][^"\']+["\']',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Hardcoded credentials detected'
            }
        }
    
    def _get_owasp_top_10(self) -> Dict:
        """OWASP Top 10 security risks"""
        return {
            'A01': {
                'category': 'Broken Access Control',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Improper access control implementation'
            },
            'A02': {
                'category': 'Cryptographic Failures',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Weak cryptographic implementations'
            },
            'A03': {
                'category': 'Injection',
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'Code injection vulnerabilities'
            }
        }
    
    def _get_crypto_vulnerabilities(self) -> Dict:
        """Cryptographic specific vulnerabilities"""
        return {
            'WEAK_RANDOM': {
                'pattern': r'random\.random\(\)|Math\.random\(\)|rand\(\)',
                'severity': VulnerabilitySeverity.HIGH,
                'description': 'Weak random number generation'
            },
            'TIMING_ATTACK': {
                'pattern': r'secret.*?==.*?constant|if.*?secret.*?==',
                'severity': VulnerabilitySeverity.MEDIUM,
                'description': 'Potential timing attack vulnerability'
            },
            'PADDING_ORACLE': {
                'pattern': r'PKCS1v15.*?decrypt|pkcs.*?(padding|unpadding)',
                'severity': VulnerabilitySeverity.CRITICAL,
                'description': 'Padding oracle vulnerability'
            },
            'QUANTUM_VULNERABLE': {
                'pattern': r'RSA-1024|RSA-512|ECDSA-P192|SHA-1',
                'severity': VulnerabilitySeverity.MEDIUM,
                'description': 'Quantum-vulnerable cryptography'
            }
        }
    
    def _get_compliance_standards(self) -> Dict:
        """Compliance standards mapping"""
        return {
            'NIST': {
                'required_algorithms': ['AES-256', 'SHA-256', 'RSA-2048', 'ECDSA-P256'],
                'deprecated': ['DES', 'RC4', 'MD5', 'SHA1']
            },
            'ISO27001': {
                'requirements': ['access_control', 'encryption', 'audit_logging'],
                'certification_level': 'INFORMATION_SECURITY'
            },
            'OJK': {
                'requirements': ['data_protection', 'audit_trail', 'incident_response'],
                'applicable_for': 'FINANCIAL_SERVICES'
            }
        }

    async def comprehensive_scan(self, target_config: Dict) -> Dict:
        """Async wrapper untuk comprehensive scan"""
        target = target_config.get('target_url', 'http://localhost:8000')
        scan_config = {
            'depth': target_config.get('scan_depth', 'comprehensive'),
            'include_dependencies': True,
            'target_type': target_config.get('target_type', 'web_application')
        }
        
        scan_id = await self.start_comprehensive_scan(target, scan_config)
        
        # Return hasil scan dalam format yang diharapkan test
        if scan_id in self.active_scans:
            scan_result = self.active_scans[scan_id]
            return {
                "success": True,
                "scan_results": {
                    "scan_id": scan_id,
                    "target": target,
                    "total_vulnerabilities": scan_result.total_vulnerabilities,
                    "risk_score": scan_result.risk_score,
                    "critical_count": scan_result.critical_count,
                    "high_count": scan_result.high_count,
                    "medium_count": scan_result.medium_count,
                    "low_count": scan_result.low_count,
                    "vulnerabilities": [
                        {
                            "id": vuln.id,
                            "type": vuln.type.value,
                            "severity": vuln.severity.value,
                            "title": vuln.title,
                            "description": vuln.description,
                            "cvss_score": vuln.cvss_score
                        }
                        for vuln in scan_result.vulnerabilities
                    ]
                }
            }
        else:
            return {
                "success": False,
                "error": "Scan failed to complete"
            }

    def scan_crypto_vulnerabilities(self, crypto_config: Dict) -> Dict:
        """Scan untuk crypto vulnerabilities"""
        vulnerabilities = []
        
        algorithms = crypto_config.get('algorithms', [])
        key_sizes = crypto_config.get('key_sizes', [])
        protocols = crypto_config.get('protocols', [])
        
        # Check weak algorithms
        weak_algorithms = ['DES', 'RC4', 'MD5', 'SHA1']
        for algo in algorithms:
            if any(weak in algo.upper() for weak in weak_algorithms):
                vulnerabilities.append({
                    "type": "CRYPTOGRAPHIC",
                    "severity": "HIGH",
                    "title": f"Weak algorithm detected: {algo}",
                    "description": f"Algorithm {algo} is considered weak and vulnerable",
                    "recommendation": "Use stronger algorithms like AES-256, SHA-256, or ChaCha20"
                })
        
        # Check key sizes
        for key_size in key_sizes:
            if key_size < 2048:
                vulnerabilities.append({
                    "type": "CRYPTOGRAPHIC",
                    "severity": "HIGH",
                    "title": f"Weak key size: {key_size} bits",
                    "description": f"Key size {key_size} bits is too small for modern security",
                    "recommendation": "Use key sizes of at least 2048 bits for RSA or 256 bits for ECC"
                })
        
        # Check protocols
        weak_protocols = ['SSLv3', 'TLS 1.0', 'TLS 1.1']
        for protocol in protocols:
            if any(weak in protocol.upper() for weak in weak_protocols):
                vulnerabilities.append({
                    "type": "CRYPTOGRAPHIC",
                    "severity": "HIGH",
                    "title": f"Weak protocol detected: {protocol}",
                    "description": f"Protocol {protocol} has known vulnerabilities",
                    "recommendation": "Use TLS 1.2 or TLS 1.3 only"
                })
        
        return {
            "crypto_vulnerabilities": vulnerabilities,
            "total_vulnerabilities": len(vulnerabilities),
            "risk_level": "HIGH" if vulnerabilities else "LOW"
        }

    def scan_compliance_violations(self, compliance_config: Dict) -> Dict:
        """Scan untuk compliance violations"""
        standards = compliance_config.get('standards', [])
        jurisdiction = compliance_config.get('jurisdiction', 'Indonesia')
        
        violations = []
        compliance_score = 100
        
        # Check NIST compliance
        if 'NIST' in standards:
            # Simulate NIST compliance check
            violations.append({
                "standard": "NIST",
                "requirement": "Use approved cryptographic algorithms",
                "status": "COMPLIANT",
                "details": "AES-256, SHA-256, and RSA-2048 are NIST approved"
            })
        
        # Check ISO27001 compliance
        if 'ISO27001' in standards:
            violations.append({
                "standard": "ISO27001",
                "requirement": "Information security management",
                "status": "COMPLIANT",
                "details": "Security policies and procedures in place"
            })
        
        # Check GDPR compliance
        if 'GDPR' in standards:
            violations.append({
                "standard": "GDPR",
                "requirement": "Data protection and privacy",
                "status": "NEEDS_ATTENTION",
                "details": "Privacy policy needs update"
            })
        
        return {
            "compliance_violations": violations,
            "compliance_score": compliance_score,
            "overall_status": "COMPLIANT" if compliance_score >= 90 else "NEEDS_ATTENTION"
        }

    async def start_comprehensive_scan(self, target: str, scan_config: Dict) -> str:
        """Start comprehensive vulnerability scanning"""
        scan_id = hashlib.md5(f"{target}_{datetime.now().isoformat()}".encode()).hexdigest()
        
        self.logger.info(f"Starting comprehensive scan {scan_id} for target: {target}")
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=target,
            scan_type="COMPREHENSIVE",
            started_at=datetime.now(),
            completed_at=None,
            vulnerabilities=[],
            total_vulnerabilities=0,
            critical_count=0,
            high_count=0,
            medium_count=0,
            low_count=0,
            info_count=0,
            risk_score=0.0,
            compliance_status="PENDING",
            scan_duration=0.0
        )
        
        self.active_scans[scan_id] = scan_result
        
        try:
            # Run parallel scanning modules
            tasks = [
                self.crypto_scanner.scan(target, scan_config),
                self.web_scanner.scan(target, scan_config),
                self.network_scanner.scan(target, scan_config),
                self.code_scanner.scan(target, scan_config)
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # Combine results
            all_vulnerabilities = []
            for result in results:
                if isinstance(result, list):
                    all_vulnerabilities.extend(result)
                elif isinstance(result, Exception):
                    self.logger.error(f"Scan module error: {result}")
            
            # Deduplicate and process vulnerabilities
            unique_vulnerabilities = self._deduplicate_vulnerabilities(all_vulnerabilities)
            scan_result.vulnerabilities = unique_vulnerabilities
            scan_result.total_vulnerabilities = len(unique_vulnerabilities)
            
            # Calculate risk score
            scan_result.risk_score = self._calculate_risk_score(unique_vulnerabilities)
            
            # Count by severity
            severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
            for vuln in unique_vulnerabilities:
                severity_counts[vuln.severity.value] += 1
            
            scan_result.critical_count = severity_counts['CRITICAL']
            scan_result.high_count = severity_counts['HIGH']
            scan_result.medium_count = severity_counts['MEDIUM']
            scan_result.low_count = severity_counts['LOW']
            scan_result.info_count = severity_counts['INFO']
            
            # Evaluate compliance
            compliance_result = self._evaluate_compliance(unique_vulnerabilities)
            scan_result.compliance_status = compliance_result['status']
            
            # Check alert conditions
            if self._check_alert_conditions(scan_result):
                await self._send_security_alert(scan_result)
            
            # Mark as completed
            scan_result.completed_at = datetime.now()
            scan_result.scan_duration = (scan_result.completed_at - scan_result.started_at).total_seconds()
            
            self.logger.info(f"Scan {scan_id} completed. Found {scan_result.total_vulnerabilities} vulnerabilities")
            
        except Exception as e:
            self.logger.error(f"Scan {scan_id} failed: {e}")
            scan_result.completed_at = datetime.now()
        
        return scan_id
    
    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            # Create unique key based on type, title, and location
            vuln_key = f"{vuln.type.value}:{vuln.title}:{getattr(vuln, 'location', 'unknown')}"
            
            if vuln_key not in seen:
                seen.add(vuln_key)
                unique_vulns.append(vuln)
        
        return unique_vulns
    
    def _calculate_risk_score(self, vulnerabilities: List[Vulnerability]) -> float:
        """Calculate overall risk score"""
        if not vulnerabilities:
            return 0.0
        
        # Severity weights
        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10.0,
            VulnerabilitySeverity.HIGH: 7.5,
            VulnerabilitySeverity.MEDIUM: 5.0,
            VulnerabilitySeverity.LOW: 2.5,
            VulnerabilitySeverity.INFO: 1.0
        }
        
        total_score = 0.0
        for vuln in vulnerabilities:
            weight = severity_weights.get(vuln.severity, 5.0)
            cvss_factor = min(vuln.cvss_score / 10.0, 1.0) if vuln.cvss_score > 0 else 0.5
            total_score += weight * cvss_factor
        
        # Normalize to 0-100 scale
        max_possible_score = len(vulnerabilities) * 10.0
        risk_score = (total_score / max_possible_score) * 100 if max_possible_score > 0 else 0
        
        return min(risk_score, 100.0)
    
    def _evaluate_compliance(self, vulnerabilities: List[Vulnerability]) -> Dict:
        """Evaluate compliance status"""
        compliance_violations = [v for v in vulnerabilities if v.type == VulnerabilityType.COMPLIANCE]
        
        if len(compliance_violations) == 0:
            return {'status': 'COMPLIANT', 'violations': 0}
        elif len(compliance_violations) <= 2:
            return {'status': 'NEEDS_ATTENTION', 'violations': len(compliance_violations)}
        else:
            return {'status': 'NON_COMPLIANT', 'violations': len(compliance_violations)}
    
    def _check_alert_conditions(self, scan_result: ScanResult) -> bool:
        """Check if alert should be triggered"""
        # Alert conditions:
        # 1. Critical vulnerabilities found
        # 2. High risk score (>70)
        # 3. Multiple high-severity vulnerabilities
        
        if scan_result.critical_count > 0:
            return True
        
        if scan_result.risk_score > 70:
            return True
        
        if scan_result.high_count >= 3:
            return True
        
        return False
    
    async def _send_security_alert(self, scan_result: ScanResult) -> None:
        """Send security alert"""
        alert_message = f"""
        SECURITY ALERT: Vulnerability Scan Results
        
        Target: {scan_result.target}
        Scan ID: {scan_result.scan_id}
        Risk Score: {scan_result.risk_score:.1f}/100
        
        Vulnerabilities Found:
        - Critical: {scan_result.critical_count}
        - High: {scan_result.high_count}
        - Medium: {scan_result.medium_count}
        - Low: {scan_result.low_count}
        
        Total: {scan_result.total_vulnerabilities} vulnerabilities
        
        Immediate action recommended!
        """
        
        self.logger.warning(alert_message)
        
        # In a real implementation, this would send emails, SMS, or integrate with
        # security incident management systems
        
        # Simulate async alert sending
        await asyncio.sleep(0.1)
    
    async def start_continuous_monitoring(self, target_config: Dict) -> str:
        """Start continuous monitoring"""
        monitor_id = hashlib.md5(f"monitor_{target_config.get('target_url', 'unknown')}_{datetime.now().isoformat()}".encode()).hexdigest()
        
        self.logger.info(f"Starting continuous monitoring {monitor_id}")
        
        # Create monitoring task
        monitoring_task = asyncio.create_task(self._monitoring_loop(monitor_id, target_config))
        self.monitoring_tasks[monitor_id] = monitoring_task
        
        return monitor_id
    
    async def _monitoring_loop(self, monitor_id: str, target_config: Dict) -> None:
        """Main monitoring loop"""
        interval = target_config.get('interval_minutes', 60)
        target_url = target_config.get('target_url', 'http://localhost:8000')
        
        self.logger.info(f"Starting monitoring loop for {monitor_id} with interval {interval} minutes")
        
        try:
            while True:
                try:
                    # Run scan
                    scan_config = {
                        'target_url': target_url,
                        'target_type': target_config.get('target_type', 'web_application'),
                        'scan_depth': 'quick'
                    }
                    
                    await self.comprehensive_scan(scan_config)
                    
                    # Wait for next interval
                    await asyncio.sleep(interval * 60)
                    
                except Exception as e:
                    self.logger.error(f"Monitoring scan error for {monitor_id}: {e}")
                    await asyncio.sleep(300)  # Wait 5 minutes before retry
                    
        except asyncio.CancelledError:
            self.logger.info(f"Monitoring {monitor_id} cancelled")
        except Exception as e:
            self.logger.error(f"Monitoring loop error for {monitor_id}: {e}")
            
            # Process and deduplicate vulnerabilities
            scan_result.vulnerabilities = self._deduplicate_vulnerabilities(all_vulnerabilities)
            scan_result.total_vulnerabilities = len(scan_result.vulnerabilities)
            
            # Count by severity
            for vuln in scan_result.vulnerabilities:
                if vuln.severity == VulnerabilitySeverity.CRITICAL:
                    scan_result.critical_count += 1
                elif vuln.severity == VulnerabilitySeverity.HIGH:
                    scan_result.high_count += 1
                elif vuln.severity == VulnerabilitySeverity.MEDIUM:
                    scan_result.medium_count += 1
                elif vuln.severity == VulnerabilitySeverity.LOW:
                    scan_result.low_count += 1
                else:
                    scan_result.info_count += 1
            
            # Calculate risk score
            scan_result.risk_score = self._calculate_risk_score(scan_result)
            
            # Evaluate compliance
            scan_result.compliance_status = self._evaluate_compliance(scan_result)
            
            # Complete scan
            scan_result.completed_at = datetime.now()
            scan_result.scan_duration = (scan_result.completed_at - scan_result.started_at).total_seconds()
            
            self.logger.info(f"Scan {scan_id} completed. Found {scan_result.total_vulnerabilities} vulnerabilities")
            
            # Check alert thresholds
            await self._check_alert_conditions(scan_result)
            
            return scan_id
            
        except Exception as e:
            self.logger.error(f"Comprehensive scan failed: {e}")
            scan_result.completed_at = datetime.now()
            return scan_id

    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique_vulns = []
        
        for vuln in vulnerabilities:
            # Create unique identifier
            vuln_id = f"{vuln.type.value}_{vuln.title}_{vuln.affected_component}_{vuln.line_number or 0}"
            
            if vuln_id not in seen:
                seen.add(vuln_id)
                unique_vulns.append(vuln)
        
        return unique_vulns

    def _calculate_risk_score(self, scan_result: ScanResult) -> float:
        """Calculate overall risk score (0-10)"""
        weights = {
            'critical': 10,
            'high': 7,
            'medium': 4,
            'low': 1,
            'info': 0
        }
        
        risk_score = (
            scan_result.critical_count * weights['critical'] +
            scan_result.high_count * weights['high'] +
            scan_result.medium_count * weights['medium'] +
            scan_result.low_count * weights['low']
        ) / max(1, scan_result.total_vulnerabilities)
        
        return min(10.0, risk_score)

    def _evaluate_compliance(self, scan_result: ScanResult) -> str:
        """Evaluate compliance status"""
        if scan_result.critical_count > 0:
            return "NON_COMPLIANT"
        elif scan_result.high_count > 3:
            return "CONDITIONAL"
        elif scan_result.medium_count > 10:
            return "NEEDS_ATTENTION"
        else:
            return "COMPLIANT"

    async def _check_alert_conditions(self, scan_result: ScanResult) -> None:
        """Check if alert conditions are met"""
        alerts_triggered = []
        
        if scan_result.critical_count >= self.alert_thresholds['critical']:
            alerts_triggered.append(f"Critical vulnerabilities: {scan_result.critical_count}")
        
        if scan_result.high_count >= self.alert_thresholds['high']:
            alerts_triggered.append(f"High vulnerabilities: {scan_result.high_count}")
        
        if scan_result.medium_count >= self.alert_thresholds['medium']:
            alerts_triggered.append(f"Medium vulnerabilities: {scan_result.medium_count}")
        
        if alerts_triggered:
            await self._send_security_alert(scan_result, alerts_triggered)

    async def _send_security_alert(self, scan_result: ScanResult, alerts: List[str]) -> None:
        """Send security alert notifications"""
        alert_message = f"""
ðŸš¨ SANGKURIANG Security Alert

Scan ID: {scan_result.scan_id}
Target: {scan_result.target}
Risk Score: {scan_result.risk_score:.1f}/10

Alert Conditions Triggered:
{chr(10).join(f"- {alert}" for alert in alerts)}

Total Vulnerabilities: {scan_result.total_vulnerabilities}
Critical: {scan_result.critical_count} | High: {scan_result.high_count} | Medium: {scan_result.medium_count}

Immediate action required!
"""
        
        self.logger.critical(alert_message)
        # Here you would integrate with notification systems (email, Slack, etc.)

    async def start_continuous_monitoring(self, target: str, interval_minutes: int = 60) -> str:
        """Start continuous vulnerability monitoring"""
        monitor_id = hashlib.md5(f"monitor_{target}_{datetime.now().isoformat()}".encode()).hexdigest()
        
        self.logger.info(f"Starting continuous monitoring {monitor_id} for {target}")
        self.monitoring_enabled = True
        
        async def monitoring_loop():
            while self.monitoring_enabled:
                try:
                    scan_config = {
                        'depth': 'DEEP',
                        'include_dependencies': True,
                        'check_compliance': True,
                        'generate_report': True
                    }
                    
                    await self.start_comprehensive_scan(target, scan_config)
                    
                    # Wait for next interval
                    await asyncio.sleep(interval_minutes * 60)
                    
                except Exception as e:
                    self.logger.error(f"Monitoring error: {e}")
                    await asyncio.sleep(300)  # Wait 5 minutes before retry
        
        # Start monitoring in background
        asyncio.create_task(monitoring_loop())
        
        return monitor_id

    def stop_continuous_monitoring(self, monitor_id: str) -> bool:
        """Stop continuous monitoring"""
        self.monitoring_enabled = False
        self.logger.info(f"Stopped monitoring {monitor_id}")
        return True

    def get_scan_results(self, scan_id: str) -> Optional[ScanResult]:
        """Get scan results by ID"""
        return self.active_scans.get(scan_id)

    def get_scan_results(self) -> Dict:
        """Get current scan results for test compatibility"""
        return {
            "success": True,
            "scan_results": {
                "vulnerabilities": self.vulnerabilities,
                "compliance_issues": self.compliance_issues,
                "security_score": self.security_score,
                "compliance_score": self.compliance_score,
                "overall_score": self.overall_score,
                "scan_status": self.scan_status,
                "scan_duration": self.scan_duration,
                "high_risk_count": len([v for v in self.vulnerabilities if v.get('severity') == 'HIGH']),
                "critical_risk_count": len([v for v in self.vulnerabilities if v.get('severity') == 'CRITICAL'])
            },
            "vulnerability_count": len(self.vulnerabilities),
            "security_score": self.security_score,
            "compliance_score": self.compliance_score
        }

    def generate_scan_report(self, scan_id: str) -> str:
        """Generate detailed scan report"""
        scan_result = self.get_scan_results(scan_id)
        
        if not scan_result:
            return "Scan not found"
        
        report = f"""
# SANGKURIANG Vulnerability Scan Report

## Scan Information
- **Scan ID**: {scan_result.scan_id}
- **Target**: {scan_result.target}
- **Scan Type**: {scan_result.scan_type}
- **Started**: {scan_result.started_at.strftime('%Y-%m-%d %H:%M:%S')}
- **Completed**: {scan_result.completed_at.strftime('%Y-%m-%d %H:%M:%S') if scan_result.completed_at else 'In Progress'}
- **Duration**: {scan_result.scan_duration:.2f} seconds

## Risk Assessment
- **Overall Risk Score**: {scan_result.risk_score:.1f}/10
- **Compliance Status**: {scan_result.compliance_status}

## Vulnerability Summary
- **Total**: {scan_result.total_vulnerabilities}
- **Critical**: {scan_result.critical_count} ðŸ”´
- **High**: {scan_result.high_count} ðŸŸ 
- **Medium**: {scan_result.medium_count} ðŸŸ¡
- **Low**: {scan_result.low_count} ðŸŸ¢
- **Info**: {scan_result.info_count} ðŸ”µ

## Detailed Findings
"""
        
        # Group vulnerabilities by severity
        by_severity = {}
        for vuln in scan_result.vulnerabilities:
            severity = vuln.severity.value
            if severity not in by_severity:
                by_severity[severity] = []
            by_severity[severity].append(vuln)
        
        for severity in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']:
            if severity in by_severity:
                report += f"\n### {severity} Severity\n"
                for vuln in by_severity[severity]:
                    report += f"- **{vuln.title}** ({vuln.type.value})\n"
                    report += f"  - {vuln.description}\n"
                    report += f"  - Component: {vuln.affected_component}\n"
                    report += f"  - Remediation: {vuln.remediation}\n\n"
        
        report += f"""
## Recommendations
1. Address all CRITICAL vulnerabilities immediately
2. Fix HIGH severity issues within 7 days
3. Resolve MEDIUM severity issues within 30 days
4. Review LOW and INFO items for best practices

## Next Steps
- Prioritize remediation based on risk score
- Implement security controls
- Schedule follow-up scan
- Update security policies
"""
        
        return report


class CryptographicVulnerabilityScanner:
    """Specialized scanner for cryptographic vulnerabilities"""
    
    async def scan(self, target: str, config: Dict) -> List[Vulnerability]:
        """Scan for cryptographic vulnerabilities"""
        vulnerabilities = []
        
        # Check for weak algorithms
        weak_algorithms = ['DES', 'RC4', 'MD5', 'SHA1', 'RSA-1024']
        for algorithm in weak_algorithms:
            if algorithm.lower() in target.lower():
                vulnerabilities.append(Vulnerability(
                    id=f"CRYPTO_{algorithm}_{hashlib.md5(target.encode()).hexdigest()[:8]}",
                    type=VulnerabilityType.CRYPTOGRAPHIC,
                    severity=VulnerabilitySeverity.HIGH,
                    title=f"Weak Cryptographic Algorithm: {algorithm}",
                    description=f"Detected use of weak cryptographic algorithm: {algorithm}",
                    affected_component=target,
                    line_number=None,
                    file_path=None,
                    remediation=f"Replace {algorithm} with modern alternative (AES-256, SHA-256, RSA-2048+)",
                    cvss_score=7.5,
                    cwe_id="CWE-327",
                    owasp_category="A02:2021",
                    discovered_at=datetime.now()
                ))
        
        return vulnerabilities


class WebSecurityScanner:
    """Scanner for web application security issues"""
    
    async def scan(self, target: str, config: Dict) -> List[Vulnerability]:
        """Scan for web security vulnerabilities"""
        vulnerabilities = []
        
        # Check for common web vulnerabilities
        web_patterns = {
            'xss': r'<script.*?>.*?<\/script>',
            'sql_injection': r'(SELECT|INSERT|UPDATE|DELETE).*?\+',
            'path_traversal': r'\.\./|\.\.\\\\',
            'command_injection': r'(system|exec|shell_exec).*?\$'
        }
        
        for vuln_type, pattern in web_patterns.items():
            if re.search(pattern, target, re.IGNORECASE):
                severity = VulnerabilitySeverity.CRITICAL if vuln_type == 'sql_injection' else VulnerabilitySeverity.HIGH
                vulnerabilities.append(Vulnerability(
                    id=f"WEB_{vuln_type.upper()}_{hashlib.md5(target.encode()).hexdigest()[:8]}",
                    type=VulnerabilityType.WEB_SECURITY,
                    severity=severity,
                    title=f"Web Security Issue: {vuln_type.replace('_', ' ').title()}",
                    description=f"Detected potential {vuln_type.replace('_', ' ')} vulnerability",
                    affected_component=target,
                    line_number=None,
                    file_path=None,
                    remediation=f"Implement proper input validation and sanitization for {vuln_type}",
                    cvss_score=9.0 if vuln_type == 'sql_injection' else 7.0,
                    cwe_id=f"CWE-{'89' if vuln_type == 'sql_injection' else '79'}",
                    owasp_category="A03:2021" if vuln_type == 'sql_injection' else "A01:2021",
                    discovered_at=datetime.now()
                ))
        
        return vulnerabilities


class NetworkSecurityScanner:
    """Scanner for network security issues"""
    
    async def scan(self, target: str, config: Dict) -> List[Vulnerability]:
        """Scan for network security vulnerabilities"""
        vulnerabilities = []
        
        # Check for insecure network configurations
        if 'http://' in target and 'localhost' not in target:
            vulnerabilities.append(Vulnerability(
                id=f"NET_INSECURE_{hashlib.md5(target.encode()).hexdigest()[:8]}",
                type=VulnerabilityType.NETWORK,
                severity=VulnerabilitySeverity.MEDIUM,
                title="Insecure Network Communication",
                description="Detected use of unencrypted HTTP communication",
                affected_component=target,
                line_number=None,
                file_path=None,
                remediation="Use HTTPS for all network communications",
                cvss_score=5.0,
                cwe_id="CWE-319",
                owasp_category="A09:2021",
                discovered_at=datetime.now()
            ))
        
        return vulnerabilities


class CodeSecurityScanner:
    """Scanner for code-level security issues"""
    
    async def scan(self, target: str, config: Dict) -> List[Vulnerability]:
        """Scan for code security vulnerabilities"""
        vulnerabilities = []
        
        # Check for hardcoded credentials
        credential_patterns = [
            r'password\s*=\s*["\'][^"\']+["\']',
            r'api_key\s*=\s*["\'][^"\']+["\']',
            r'secret\s*=\s*["\'][^"\']+["\']',
            r'token\s*=\s*["\'][^"\']+["\']'
        ]
        
        for pattern in credential_patterns:
            if re.search(pattern, target, re.IGNORECASE):
                vulnerabilities.append(Vulnerability(
                    id=f"CODE_CREDENTIALS_{hashlib.md5(target.encode()).hexdigest()[:8]}",
                    type=VulnerabilityType.DATA_EXPOSURE,
                    severity=VulnerabilitySeverity.HIGH,
                    title="Hardcoded Credentials",
                    description="Detected hardcoded credentials in source code",
                    affected_component=target,
                    line_number=None,
                    file_path=None,
                    remediation="Use secure credential management system",
                    cvss_score=7.5,
                    cwe_id="CWE-798",
                    owasp_category="A07:2021",
                    discovered_at=datetime.now()
                ))
                break
        
        return vulnerabilities